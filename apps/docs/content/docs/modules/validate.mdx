---
title: "Validate"
description: Schema-first validation for CLI arguments and flags using validation libraries.
---

`@crustjs/validate` provides schema-first validation and coercion for Crust commands. Define your args and flags as schemas, and the package generates parser definitions, runs validation, and delivers fully typed, transformed values to your handler.

## Supported Validators

| Provider                          | Entrypoint                 | Define Function       |
| --------------------------------- | -------------------------- | --------------------- |
| [Zod 4](#zod-provider)            | `@crustjs/validate/zod`    | `defineZodCommand`    |
| [Effect Schema](#effect-provider) | `@crustjs/validate/effect` | `defineEffectCommand` |

The root entrypoint (`@crustjs/validate`) exports [shared types](#shared-exports) only.

## Install

```sh
bun add @crustjs/validate
```

Then install the validator of your choice:

```sh
# Zod
bun add zod

# Effect
bun add effect
```

`@crustjs/core` is a required peer dependency.

## How It Works

1. You declare args with `arg(name, schema)` and flags with plain schemas or `flag(schema, options)` wrappers.
2. The `define*Command()` function introspects schemas at definition time to generate the core `ArgDef[]` and `FlagsDef` that Crust's parser needs.
3. At runtime, after Crust parses argv, each value is validated and transformed through its schema before your `run` handler is called.
4. Validation errors are collected and thrown as a single `CrustError("VALIDATION")` with structured `details.issues`.

---

## Zod Provider

Import from `@crustjs/validate/zod`.

### Quick Example (Zod)

```ts
import { runMain } from "@crustjs/core";
import { arg, defineZodCommand, flag } from "@crustjs/validate/zod";
import { z } from "zod";

const greet = defineZodCommand({
  meta: { name: "greet", description: "Say hello" },
  args: [arg("name", z.string())],
  flags: {
    loud: flag(z.boolean().default(false), {
      alias: "l",
      description: "Shout the greeting",
    }),
  },
  run({ args, flags }) {
    // args.name is string, flags.loud is boolean — fully typed
    const msg = `Hello, ${args.name}!`;
    console.log(flags.loud ? msg.toUpperCase() : msg);
  },
});

runMain(greet);
```

### Schema Support (Zod)

- **Primitives**: `z.string()`, `z.number()`, `z.boolean()`
- **Enums and literals**: `z.enum(["a", "b"])`, `z.literal("value")`
- **Arrays**: `z.array(z.string())` (flags with `multiple: true`)
- **Wrappers**: `.optional()`, `.default()`, `.nullable()`, `.transform()`, `.pipe()`
- **Descriptions**: `z.string().describe("Help text")` (auto-extracted for help output)

Schemas are introspected at definition time to determine CLI parser types (`string`, `number`, `boolean`) and optionality. Transforms and pipes are unwrapped to find the input type.

### Variadic Args (Zod)

The last positional arg can be variadic, collecting all remaining positionals into an array:

```ts
const cmd = defineZodCommand({
  meta: { name: "rm" },
  args: [arg("files", z.string(), { variadic: true })],
  run({ args }) {
    // args.files is string[]
    for (const file of args.files) {
      console.log(`Removing ${file}`);
    }
  },
});
```

Use a scalar schema (not `z.array()`). The framework handles array collection. Compile-time validation ensures variadic args are only in the last position.

### Exports (Zod)

#### Functions

| Function           | Description                                              |
| ------------------ | -------------------------------------------------------- |
| `defineZodCommand` | Define a command with Zod schemas as the source of truth |
| `arg`              | Declare a named positional argument with a Zod schema    |
| `flag`             | Wrap a Zod schema with alias and description metadata    |

#### Types

| Type                                      | Description                                  |
| ----------------------------------------- | -------------------------------------------- |
| `ZodCommandDef<A, F>`                     | Config shape for `defineZodCommand`          |
| `ZodCommandRunHandler<ArgsOut, FlagsOut>` | Handler receiving `ValidatedContext`         |
| `ArgSpec<Name, Schema, Variadic>`         | A single positional arg spec from `arg()`    |
| `ArgSpecs`                                | Ordered readonly array of `ArgSpec`          |
| `ArgOptions`                              | Options for `arg()` (description, variadic)  |
| `FlagSpec<Schema, Alias>`                 | A flag wrapper from `flag()`                 |
| `FlagShape`                               | Record of plain schemas or `FlagSpec` values |
| `FlagOptions`                             | Options for `flag()` (alias, description)    |
| `ZodSchemaLike`                           | Zod schema type constraint                   |
| `InferSchemaOutput<S>`                    | Infer output type from a Zod schema          |
| `InferArgsFromSpecs<A>`                   | Infer validated args object from arg specs   |
| `InferArgsFromConfig<A>`                  | Infer args output from command config        |
| `InferFlagsFromShape<F>`                  | Infer validated flags object from flag shape |
| `InferFlagsFromConfig<F>`                 | Infer flags output from command config       |

---

## Effect Provider

Import from `@crustjs/validate/effect`.

> **Constraint:** Only context-free schemas (`R = never`) are supported in v1. Schemas that require an Effect context will produce a type error.

### Quick Example (Effect)

```ts
import { runMain } from "@crustjs/core";
import { arg, defineEffectCommand, flag } from "@crustjs/validate/effect";
import { Schema } from "effect";

const greet = defineEffectCommand({
  meta: { name: "greet", description: "Say hello" },
  args: [arg("name", Schema.String)],
  flags: {
    loud: flag(Schema.optionalWith(Schema.Boolean, { default: () => false }), {
      alias: "l",
      description: "Shout the greeting",
    }),
  },
  run({ args, flags }) {
    // args.name is string, flags.loud is boolean — fully typed
    const msg = `Hello, ${args.name}!`;
    console.log(flags.loud ? msg.toUpperCase() : msg);
  },
});

runMain(greet);
```

### Schema Support (Effect)

- **Primitives**: `Schema.String`, `Schema.Number`, `Schema.Boolean`
- **Enums and literals**: `Schema.Literal("a", "b")`, `Schema.Enums(MyEnum)`
- **Arrays**: `Schema.Array(Schema.String)` (flags with `multiple: true`)
- **Wrappers**: `Schema.optional(...)`, `Schema.optionalWith(...)`, `Schema.transform(...)`, `Schema.TemplateLiteral`
- **Descriptions**: `schema.annotations({ description: "Help text" })` (auto-extracted for help output)

Schemas are introspected via AST at definition time to determine CLI parser types (`string`, `number`, `boolean`) and optionality. Transformations and refinements are unwrapped to find the encoded input type.

### Variadic Args (Effect)

The last positional arg can be variadic, collecting all remaining positionals into an array:

```ts
const cmd = defineEffectCommand({
  meta: { name: "rm" },
  args: [arg("files", Schema.String, { variadic: true })],
  run({ args }) {
    // args.files is string[]
    for (const file of args.files) {
      console.log(`Removing ${file}`);
    }
  },
});
```

Use a scalar schema (not `Schema.Array()`). The framework handles array collection. Compile-time validation ensures variadic args are only in the last position.

### Exports (Effect)

#### Functions

| Function              | Description                                                 |
| --------------------- | ----------------------------------------------------------- |
| `defineEffectCommand` | Define a command with Effect schemas as the source of truth |
| `arg`                 | Declare a named positional argument with an Effect schema   |
| `flag`                | Wrap an Effect schema with alias and description metadata   |

#### Types

| Type                                         | Description                                  |
| -------------------------------------------- | -------------------------------------------- |
| `EffectCommandDef<A, F>`                     | Config shape for `defineEffectCommand`       |
| `EffectCommandRunHandler<ArgsOut, FlagsOut>` | Handler receiving `ValidatedContext`         |
| `ArgSpec<Name, Schema, Variadic>`            | A single positional arg spec from `arg()`    |
| `ArgSpecs`                                   | Ordered readonly array of `ArgSpec`          |
| `ArgOptions`                                 | Options for `arg()` (description, variadic)  |
| `FlagSpec<Schema, Alias>`                    | A flag wrapper from `flag()`                 |
| `FlagShape`                                  | Record of plain schemas or `FlagSpec` values |
| `FlagOptions`                                | Options for `flag()` (alias, description)    |
| `EffectSchemaLike`                           | Effect schema type constraint (`R = never`)  |
| `InferSchemaOutput<S>`                       | Infer output type from an Effect schema      |
| `InferArgsFromSpecs<A>`                      | Infer validated args object from arg specs   |
| `InferArgsFromConfig<A>`                     | Infer args output from command config        |
| `InferFlagsFromShape<F>`                     | Infer validated flags object from flag shape |
| `InferFlagsFromConfig<F>`                    | Infer flags output from command config       |

---

## Shared Behavior

These apply to both the Zod and Effect providers.

### Compile-Time Validation

Both `defineZodCommand` and `defineEffectCommand` inherit the same compile-time checks as `defineCommand`:

- **Variadic position** — only the last arg can be `{ variadic: true }`
- **Flag alias collisions** — aliases must not conflict with other flag names or aliases

These produce TypeScript errors at the call site if violated.

### Error Handling

When validation fails, a `CrustError("VALIDATION")` is thrown with:

- A human-readable bullet-list message suitable for CLI output
- Structured `details.issues` array of `{ message, path }` objects

```
Validation failed
  - args.name: Expected string, received number
  - flags.port: Number must be greater than or equal to 1
```

### Shared Exports

The root entrypoint `@crustjs/validate` exports shared types used by both providers:

| Type                                  | Description                                                                              |
| ------------------------------------- | ---------------------------------------------------------------------------------------- |
| `ValidatedContext<ArgsOut, FlagsOut>` | Extended command context with validated args, flags, and `input` (pre-validation values) |
| `ValidationIssue`                     | Normalized issue with `message` and dot-path `path` string                               |

## When to Use

Use `@crustjs/validate/zod` when:

- You want schemas as the single source of truth for parsing, validation, help text, and types
- You need transforms or coercion (e.g., parsing a string into a `Date`)
- You want fully inferred handler types without manual annotation

Use `@crustjs/validate/effect` when:

- You already use Effect and want schema-driven command validation
- You want Effect-style schema composition and parse errors

Use `@crustjs/core` directly when:

- You don't need runtime schema validation
- You want zero additional dependencies
