---
title: Subcommands
description: Build nested command trees with automatic routing.
---

import { Callout } from "fumadocs-ui/components/callout";

Subcommands let you organize your CLI into a tree of nested commands, like `git commit` or `docker compose up`.

## Defining Subcommands

Add subcommands to a parent command using the `subCommands` property:

```ts
import { defineCommand, runMain, helpPlugin } from "@crustjs/crust";

const build = defineCommand({
  meta: { name: "build", description: "Build the project" },
  flags: {
    minify: { type: "boolean", default: true },
  },
  run({ flags }) {
    console.log(`Building... (minify: ${flags.minify})`);
  },
});

const dev = defineCommand({
  meta: { name: "dev", description: "Start dev server" },
  flags: {
    port: { type: "number", default: 3000, alias: "p" },
  },
  run({ flags }) {
    console.log(`Dev server on port ${flags.port}`);
  },
});

const main = defineCommand({
  meta: { name: "my-cli", description: "My CLI tool" },
  subCommands: { build, dev },
});

runMain(main, { plugins: [helpPlugin()] });
```

```sh
my-cli build              # Runs the build command
my-cli dev --port 8080    # Runs the dev command
my-cli --help             # Shows help with available subcommands
```

## How Routing Works

When Crust receives `argv`, it walks the subcommand tree **before** parsing flags or arguments. Each token is checked against subcommand names — if it matches, Crust recurses into that subcommand. If no match is found, the token is treated as a positional arg (when the command has `run()`) or throws a `COMMAND_NOT_FOUND` error (when it doesn't).

This means subcommand names are consumed before flag parsing, so `my-cli build --minify` first resolves `build`, then parses `--minify` against the build command's flags. See the [resolveCommand() reference](/docs/api/resolve-command#resolution-algorithm) for the detailed step-by-step algorithm.

## Nested Subcommands

Subcommands can be nested arbitrarily deep:

```ts
const createComponent = defineCommand({
  meta: { name: "component", description: "Create a component" },
  args: [{ name: "name", type: "string", required: true }] as const,
  run({ args }) {
    console.log(`Creating component: ${args.name}`);
  },
});

const createPlugin = defineCommand({
  meta: { name: "plugin", description: "Create a plugin" },
  args: [{ name: "name", type: "string", required: true }] as const,
  run({ args }) {
    console.log(`Creating plugin: ${args.name}`);
  },
});

const create = defineCommand({
  meta: { name: "create", description: "Create resources" },
  subCommands: {
    component: createComponent,
    plugin: createPlugin,
  },
});

const main = defineCommand({
  meta: { name: "my-cli" },
  subCommands: { create },
});
```

```sh
my-cli create component Button
my-cli create plugin auth
```

## Container Commands

A command with `subCommands` but no `run` handler is a **container command**. It exists purely to group subcommands:

```ts
const main = defineCommand({
  meta: { name: "my-cli", description: "My CLI tool" },
  subCommands: { build, dev, create },
  // No run() — this is a container
});
```

When a user runs a container command directly (e.g., `my-cli` with no subcommand), the help plugin automatically shows help with the available subcommands.

## Commands with Both `run` and Subcommands

A command can have both `run()` and `subCommands`. In this case:
- If the first argument matches a subcommand name, it routes to that subcommand
- Otherwise, the arguments are treated as positionals for the parent command

```ts
const main = defineCommand({
  meta: { name: "my-cli" },
  args: [{ name: "file", type: "string" }] as const,
  subCommands: { build, dev },
  run({ args }) {
    // Runs when no subcommand matches
    console.log(`Processing file: ${args.file}`);
  },
});
```

```sh
my-cli build        # Routes to build subcommand
my-cli readme.md    # Runs parent command with file="readme.md"
```

## Unknown Subcommands

When a user types an unknown subcommand on a container command (no `run`), Crust throws a `COMMAND_NOT_FOUND` error with structured details:

```ts
{
  input: "buld",              // What the user typed
  available: ["build", "dev"], // Valid subcommands
  commandPath: ["my-cli"],     // Path to the parent
  parentCommand: main,         // The parent command object
}
```

The [Autocomplete Plugin](/docs/modules/plugins/autocomplete) catches these errors and provides "Did you mean?" suggestions.

## Command Path

Crust tracks the full command path during routing. This is used by the help plugin to generate correct usage text:

```sh
$ my-cli create component --help
my-cli create component - Create a component

USAGE:
  my-cli create component <name> [options]
```

The path `["my-cli", "create", "component"]` is available in the `CommandRoute` returned by `resolveCommand`.
