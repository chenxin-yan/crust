---
title: defineCommand()
description: Define a CLI command with full type inference.
---

Creates a frozen, immutable command object from a definition. Arguments, flags, and lifecycle hooks are fully typed based on the definitions provided.

## Signature

```ts
function defineCommand<
  const A extends ArgsDef = ArgsDef,
  const F extends FlagsDef = FlagsDef,
>(
  config: CommandDef<A, F> & {
    args?: ValidateVariadicArgs<A>;
    flags?: ValidateFlagAliases<F>;
  },
): Command<A, F>;
```

## Parameters

### `config`

The command definition object.

| Property | Type | Required | Description |
| --- | --- | --- | --- |
| `meta` | `CommandMeta` | Yes | Command metadata |
| `meta.name` | `string` | Yes | Command name (must be non-empty) |
| `meta.description` | `string` | No | Description for help text |
| `meta.usage` | `string` | No | Custom usage string |
| `args` | `ArgsDef` | No | Positional argument definitions (ordered tuple) |
| `flags` | `FlagsDef` | No | Named flag definitions (record) |
| `subCommands` | `Record<string, AnyCommand>` | No | Named subcommands |
| `preRun` | `(ctx: CommandContext) => void \| Promise<void>` | No | Called before `run()` |
| `run` | `(ctx: CommandContext) => void \| Promise<void>` | No | Main command handler |
| `postRun` | `(ctx: CommandContext) => void \| Promise<void>` | No | Called after `run()` (always, even on error) |

## Returns

A frozen `Command<A, F>` object. The returned object is immutable via `Object.freeze`.

## Throws

- **`CrustError("DEFINITION")`** — If `meta.name` is empty or whitespace-only

## Compile-Time Checks

`defineCommand` performs two compile-time validations with per-item error targeting:

1. **`ValidateVariadicArgs<A>`** — Ensures only the last positional argument has `variadic: true`
2. **`ValidateFlagAliases<F>`** — Ensures no flag alias collides with another flag name or alias

On error, these types add branded properties (`FIX_VARIADIC_POSITION` or `FIX_ALIAS_COLLISION`) to the specific offending arg/flag so the TypeScript squiggle appears on the exact problematic item.

## Examples

### Basic Command

```ts
const greet = defineCommand({
  meta: { name: "greet", description: "Say hello" },
  run() {
    console.log("Hello!");
  },
});
```

### With Arguments and Flags

```ts
const serve = defineCommand({
  meta: { name: "serve", description: "Start server" },
  args: [
    { name: "port", type: "number", default: 3000 },
  ] as const,
  flags: {
    host: { type: "string", default: "localhost" },
    verbose: { type: "boolean", alias: "v" },
  },
  run({ args, flags }) {
    // args.port: number
    // flags.host: string
    // flags.verbose: boolean | undefined
    console.log(`Listening on ${flags.host}:${args.port}`);
  },
});
```

### With Subcommands

```ts
const main = defineCommand({
  meta: { name: "my-cli" },
  subCommands: {
    serve,
    build: defineCommand({
      meta: { name: "build", description: "Build project" },
      run() {
        console.log("Building...");
      },
    }),
  },
});
```

### With Lifecycle Hooks

```ts
const deploy = defineCommand({
  meta: { name: "deploy" },
  async preRun() {
    await validateConfig();
  },
  async run({ flags }) {
    await deployToEnvironment(flags.env);
  },
  async postRun() {
    await cleanup();
  },
});
```
