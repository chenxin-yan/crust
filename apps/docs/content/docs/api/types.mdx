---
title: Types Reference
description: All exported types and interfaces from @crustjs/core.
---

Complete reference of all types exported from `@crustjs/core`.

## Command Types

### `CommandDef<A, F>`

The command definition input shape accepted by `defineCommand`.

```ts
interface CommandDef<A extends ArgsDef = ArgsDef, F extends FlagsDef = FlagsDef> {
  meta: CommandMeta;
  args?: A;
  flags?: F;
  subCommands?: Record<string, AnyCommand>;
  preRun?(context: CommandContext<NoInfer<A>, NoInfer<F>>): void | Promise<void>;
  run?(context: CommandContext<NoInfer<A>, NoInfer<F>>): void | Promise<void>;
  postRun?(context: CommandContext<NoInfer<A>, NoInfer<F>>): void | Promise<void>;
}
```

`NoInfer` ensures `A`/`F` are inferred from `args`/`flags` definitions (data properties), not from callback parameter annotations.

### `Command<A, F>`

The frozen command shape returned by `defineCommand` and used at runtime.

```ts
interface Command<A extends ArgsDef = ArgsDef, F extends FlagsDef = FlagsDef> {
  readonly meta: CommandMeta;
  readonly args?: A;
  readonly flags?: F;
  readonly subCommands?: Record<string, AnyCommand>;
  preRun?(context: CommandContext<A, F>): void | Promise<void>;
  run?(context: CommandContext<A, F>): void | Promise<void>;
  postRun?(context: CommandContext<A, F>): void | Promise<void>;
}
```

### `AnyCommand`

Type-erased command for collections and routing. Uses `any` for type parameters to enable bivariant checking:

```ts
type AnyCommand = Command<any, any>;
```

### `CommandMeta`

Metadata describing a command:

```ts
interface CommandMeta {
  name: string;          // Command name (required)
  description?: string;  // Help text description
  usage?: string;        // Custom usage string
}
```

### `CommandContext<A, F>`

Runtime context passed to `preRun`, `run`, and `postRun` hooks:

```ts
interface CommandContext<A extends ArgsDef, F extends FlagsDef>
  extends ParseResult<A, F> {
  command: AnyCommand;  // The resolved command being executed
}
```

## Argument Types

### `ArgDef`

Defines a single positional argument. Discriminated union by `type` for type-safe defaults:

```ts
type ArgDef = StringArgDef | NumberArgDef | BooleanArgDef;
```

Each variant constrains `default` to match its `type`. Boolean toggle fields (`required`, `variadic`) only accept `true`:

```ts
// String variant (Number and Boolean follow the same shape)
interface StringArgDef {
  name: string;          // Argument name
  type: "string";        // Type discriminant
  description?: string;  // Help text
  default?: string;      // Default value (type-safe)
  required?: true;       // Error if missing
  variadic?: true;       // Collect remaining into array
}
```

### `ArgsDef`

Ordered tuple of argument definitions:

```ts
type ArgsDef = readonly ArgDef[];
```

## Flag Types

### `FlagDef`

Defines a single named flag. Discriminated union by `type` and `multiple`:

```ts
type FlagDef =
  | StringFlagDef | NumberFlagDef | BooleanFlagDef           // single-value
  | StringMultiFlagDef | NumberMultiFlagDef | BooleanMultiFlagDef; // multi-value
```

Single-value variants use `multiple?: never` (field absent); multi-value variants require `multiple: true`:

```ts
// Single-value string flag
interface StringFlagDef {
  type: "string";              // Type discriminant
  description?: string;        // Help text
  default?: string;            // Default value (type-safe)
  required?: true;             // Error if missing
  alias?: string | string[];   // Short alias(es)
  multiple?: never;            // Absent for single-value flags
}

// Multi-value string flag
interface StringMultiFlagDef {
  type: "string";              // Type discriminant
  description?: string;        // Help text
  default?: string[];          // Default array value (type-safe)
  required?: true;             // Error if missing
  alias?: string | string[];   // Short alias(es)
  multiple: true;              // Collect repeated values into array
}
// Number and boolean variants follow the same pattern
```

Boolean toggle fields (`required`, `multiple`) only accept `true` â€” passing `false` is a type error.

### `FlagsDef`

Record mapping flag names to definitions:

```ts
type FlagsDef = Record<string, FlagDef>;
```

## Inference Types

### `InferArgs<A>`

Maps an `ArgsDef` tuple to resolved arg types:

```ts
type InferArgs<A> = A extends ArgsDef ? /* resolved types */ : Record<string, never>;
```

**Resolution rules:**

| Definition | Inferred Type |
| --- | --- |
| `{ type: "string" }` | `string \| undefined` |
| `{ type: "string", required: true }` | `string` |
| `{ type: "string", default: "hi" }` | `string` |
| `{ type: "number" }` | `number \| undefined` |
| `{ type: "number", default: 3000 }` | `number` |
| `{ type: "string", variadic: true }` | `string[]` |

### `InferFlags<F>`

Maps a `FlagsDef` record to resolved flag types:

```ts
type InferFlags<F> = F extends FlagsDef ? /* resolved types */ : Record<string, never>;
```

**Resolution rules:**

| Definition | Inferred Type |
| --- | --- |
| `{ type: "string" }` | `string \| undefined` |
| `{ type: "string", required: true }` | `string` |
| `{ type: "string", default: "hi" }` | `string` |
| `{ type: "boolean" }` | `boolean \| undefined` |
| `{ type: "string", multiple: true }` | `string[] \| undefined` |
| `{ type: "string", multiple: true, required: true }` | `string[]` |

## Parse Types

### `ParseResult<A, F>`

Output of `parseArgs`:

```ts
interface ParseResult<A extends ArgsDef, F extends FlagsDef> {
  args: InferArgs<A>;     // Resolved positional arguments
  flags: InferFlags<F>;   // Resolved flags
  rawArgs: string[];       // Arguments after `--`
}
```

## Routing Types

### `CommandRoute`

Output of `resolveCommand`:

```ts
interface CommandRoute {
  command: AnyCommand;     // The resolved command
  argv: string[];           // Remaining argv
  commandPath: string[];    // Full command path
}
```

## Plugin Types

### `CrustPlugin`

The plugin interface:

```ts
interface CrustPlugin {
  name?: string;
  setup?: (context: SetupContext, actions: SetupActions) => void | Promise<void>;
  middleware?: PluginMiddleware;
}
```

### `SetupContext`

Context available during plugin setup:

```ts
interface SetupContext {
  readonly argv: readonly string[];
  readonly rootCommand: AnyCommand;
  readonly state: PluginState;
}
```

### `SetupActions`

Actions available during plugin setup:

```ts
interface SetupActions {
  addFlag(command: AnyCommand, name: string, def: FlagDef): void;
}
```

### `MiddlewareContext`

Context available during middleware execution:

```ts
interface MiddlewareContext {
  readonly argv: readonly string[];
  readonly rootCommand: AnyCommand;
  readonly state: PluginState;
  route: Readonly<CommandRoute> | null;
  input: ParseResult | null;
}
```

### `PluginMiddleware`

Middleware function type:

```ts
type PluginMiddleware = (
  context: MiddlewareContext,
  next: () => Promise<void>,
) => void | Promise<void>;
```

## Run Types

### `RunOptions`

Options for `runCommand` and `runMain`:

```ts
interface RunOptions {
  argv?: string[];
  plugins?: CrustPlugin[];
}
```

## Compile-Time Validation Types

### `ValidateVariadicArgs<A>`

Per-arg validation used by `defineCommand`. Enforces that only the last positional argument can use `variadic: true`.

```ts
type ValidateVariadicArgs<A extends ArgsDef> = /* ... */;
// On error, the offending arg gets a branded property:
// { readonly FIX_VARIADIC_POSITION: "Only the last positional argument can be variadic" }
```

### `ValidateFlagAliases<F>`

Per-flag validation used by `defineCommand`. Enforces that aliases do not collide with other flag names or aliases.

```ts
type ValidateFlagAliases<F extends FlagsDef> = /* ... */;
// On error, the offending flag gets a branded property:
// { readonly FIX_ALIAS_COLLISION: `Alias "${...}" collides with another flag name or alias` }
```
